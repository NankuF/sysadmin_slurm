# Улитилы

- apt remove htop - удалит htop, оставив файлы конфигурации
- apt purge htop - полностью удалить htop вместе с файлами конфигурации

- free -  показывает объем доступной и используемой оперативной памяти (free -h)
- du - disk usage (du -sh /var/log, du -sh /var/*, du -sh /var/)
- df - disk free (df -h)
- iotop - мониторинг процессов, активно работающих с диском.
- iftop - отслеживает сетевую активность для выявления ботов и сканеры.
- ping - доступность хоста (ping 188.93.16.19)
- traceroute - показывает путь до удаленного сервера (traceroute ya.ru)
- ss - показывает активные подключения и открытые порты (ss -tuln, ss -tulpan)
- curl - отправка http запросов
- wget - скачать файл
- sort - сортировка вывода (ls -l /var/*log* | sort -n -k 5  - по размеру файла)


### Журналы
- /var/log - место хранения логов
- journald - система логирования
- journalctl - просмотр логов
Последние 50 сообщений
```bash
journalctl -n 50
```
Логи с фильтром по времени
```bash
journalctl --since "2024-11-01"
```
- dmesg - просмотр системных сообщений ядра
```bash
dmesg |grep usb
```
Ограничение по уровню важности
```bash
dmesg -l err,warn
```
- /var/log/syslog — системные события,
- /var/log/auth.log — логи авторизации,
- /var/log/nginx/access.log — доступ к веб-серверу Nginx.

- systemctl list-units --type=service --state=active - Получите список всех активных служб.
- journalctl -k - Прочитайте из системного журнала последние сообщения, связанные с ядром (kernel).

- /proc - данные в реальном времени о процессах, cpu и памяти
- /proc/meminfo
- /proc/cpuinfo
- /proc/1234/

- /dev/  - информация о девайсах (диски, терминал, интерфейсы, мышь, клавиатура и тд)

### Фишки
- mkdir ~/project/{data,backup} - команда создает сразу две директории: data и backup внутри папки ~/project

### Архивация
tar -czf backup.tar.gz /var/log   (-create, -zip, -file) - создать сжатый архив
tar -xzf backup.tar.gz    (-extract, -zip, -file) - извлечь в текущую директорию
tar -xzvf abackup.tar.gz -C /home/user/myfolder/ -извлечь в другую директорию
tar -tzf backup.tar.gz - посмотреть содержимое архива

find /var/log -type f -mtime +7 -exec rm -f {} - найти у идалитиь файлы старше 7 дней.


### Безопасная передача файлов между серверами
scp logs_backup.tar.gz user@192.168.1.10:/backups - с локального на сервер
scp user@192.168.1.10:/backups/logs_backup.tar.gz . - с сервера на локальный
scp -r user@192.168.1.10:/backups/my_folder /local/destination/ - рекурсиваня передача каталогов с сервера на локальный
scp -P 2222 user@192.168.1.10:/backups/logs_backup.tar.gz /local/destination/ - со сменой порта

### Работа с текстом
less +/port /usr/local/fast-nginx/conf/f-stack.conf - открыть сразу на поиск слова port
cat -n selectel.txt (включить нумерацию строк)
cat >> selectel.txt (записать в конец, чтобы сохранить нажми ctrl+d 2 раза)
grep -i "error" /var/log/syslog   - i регистронезависимый поиск

### Логи
/var/log/syslog — общий системный лог (все события системы);
/var/log/auth.log — логи аутентификации (входы в систему, sudo и т. д.);
/var/log/kern.log — сообщения ядра Linux;
/var/log/dmesg — логи загрузки и работы драйверов.

В современных на systemd дистрибутивах логи хранятся в бинарном формате и управляются с помощью journalctl — утилиты с множеством функций. Рассмотрим их подробнее.
Для вывода всех логов достаточно прописать команду journalctl в консоли.

В интерфейсе journalctl мы можем использовать навигацию, которая схожа с less:
Space — прокрутка на страницу вниз;
Enter — прокрутка на одну строку вниз;
PgUp / PgDn — прокрутка на страницу вверх / вниз;
Home / End — переход в начало / конец логов;
↑/↓ — прокрутка по строкам;
/ — поиск вперед;
? — поиск назад;
q — выход из просмотра.

При этом есть множество удобных параметров командной строки, с помощью которых мы можем удобно фильтровать логи. После выполнения каждой из этих команд вы попадете в знакомое меню, с которым уже умеете работать:
journalctl -e — переход к концу логов (самые свежие записи);
journalctl -n 20 — просмотр последних 20 записей;
journalctl --since "09:00" — показ логов с указанного времени;
journalctl --until "1 hour ago" — показ логов до указанного времени.

Все сервисы, которые записывают данные в журнал, отображаются в одном общем логе. Чтобы вывести записи по конкретному сервису, используйте параметры фильтрации:
journalctl -u nginx — логи только для сервиса Nginx;
journalctl -u sshd --since today — логи sshd за сегодня;
journalctl -k — только логи ядра (аналог dmesg).

Вы можете дополнительно использовать параметр --grep, чтобы находить нужные подстроки:
journalctl -k --grep BIOS — сообщения ядра, которые содержат BIOS;
journalctl -u openvswitch --grep WARN --since "7 days ago" — все предупреждения от openvswitch за последнюю неделю.

Логи можно также запустить в режиме реального времени — для этого нужно использовать флаг -f:
journalctl -u NetworkManager.service -f

journalctl -u sshd -p err
-p err — отображает только сообщения с уровнем err (ошибки) и выше. Например, crit, alert и emerg. Доступные уровни: emerg (0), alert (1), crit (2), err (3), warning (4), notice (5), info (6), debug (7).

Посмотреть кто выполнял команды от sudo
sudo journalctl _COMM=sudo

### Автоматическое выполнение команд
Регулярная проверка (раз в пять секунд) последних 20 строк лога на наличие ошибок 500 от Nginx:
watch -n 5 "tail -n 20 /var/log/nginx/error.log | grep '500'"
Отслеживание частоты процессора с периодом в две секунды:
watch -n 2 "lscpu | grep 'MHz'"
Вывод текущей даты:
watch -n 1 "date"

### Cron
При вызове команды crontab -e мы можем редактировать файл-инструкцию по cron:

Мануал по синтаксису crontab.
Событие в расписании представляет собой строку из шести параметров: <минута>, <час>, <день месяца>, <месяц>, <день недели>, <команда>. Рассмотрим допустимые значения:
минута — от 0 до 59;
час — от 0 до 23;
день месяца — от 1 до 31;
месяц — от 1 до 12;
день недели — от 0 до 7 (0 и 7 — это воскресенье);
команда — любая команда или скрипт.
Рассмотрим спецсимволы:
* — любое значение;
*/N — каждые N единиц (например, */15 — каждые 15 минут);
N-M — диапазон значений (например, 8-17);
N,M,K — список значений (например, 9,12,15).
Рассмотрим несколько примеров расписаний:
0 * * * * — каждый час, в начале часа (нулевая минута);
*/15 * * * * — каждые 15 минут;
0 3 * * * — каждый день в 3:00 ночи;
0 0 * * 0 — каждое воскресенье в 00:00;
0 4 1 * * — первого числа каждого месяца в 4:00;
5,35 * * * * — в 5 и 35 минут каждого часа;
0 9,12,15 * * * — в 9:00, 12:00 и 15:00 каждый день;
*/12 8-17 * * * — каждые 12 минут с 8:00 до 17:59;
0 0-6/2 * * * — каждые два часа с 00:00 до 06:00.
Пример: вывод списка файлов каждую минуту

Напишем простое событие, которое будет выводить ls / в файл. Для эксперимента будем использовать ежеминутный период — * * * * *.
1. Открываем редактор crontab:
crontab -e

Интерфейс crontab.
2. Добавляем строку:
* * * * * ls / > /root/cron.tmp
3. Сохраняем файл и выходим (в зависимости от редактора — например, в Vim: Esc, :wq).
4. Проверяем, что задание добавилось:
crontab -l

Текущие события cron.
5. Укажем путь для сохранения вывода: /root/cron.tmp. Проверить ее можно с помощью следующей команды:
cat /root/cron.tmp

Содержимое файла /root/cron.tmp Убедились, что файл действительно существует и в нем находятся строки с выводом ls /.
Дополнительные примеры для использования cron
Запуск скрипта в 5:00 и 17:00 по будням, но только в первые семь дней месяца. Полезно для генерации ежемесячных отчетов в рабочее время:
0 5,17 * * 1-5 [ $(date +\%d) -le 7 ] && /usr/bin/monthly_report.sh
Мониторинг серверов каждые два часа с 8:00 до 18:00 по будням:
0 8-18/2 * * 1-5 /usr/bin/check_servers.sh
Ежечасная проверка на наличие файла /tmp/urgent.flag. Команда запускает скрипт только при наличии данного файла-флага.
0 * * * * [ -f /tmp/urgent.flag ] && /usr/bin/process_urgent.sh
Если задания больше не нужны, удалить их можно с помощью команды crontab -r.
Используйте фильтрацию логов, чтобы быстрее находить нужную информацию, и автоматизируйте рутинные задачи — это поможет не только быстрее реагировать на проблемы, но и предотвращать их заранее.

## Безопасная работа с /etc/passwd /etc/group
vipw — для работы с /etc/passwd,
vigr — для /etc/group.
Опция -s предназначена для редактирования файлов с хешированными паролями:
vipw -s — для работы с /etc/shadow,
vigr -s — для /etc/gshadow.

## Безопасное удаление пользователя
1) завершить процессы
pkill -u username
2) удалить вместе с группой
sudo userdel -r username   or sudo deluser --remove-home username

### Ограничение прав по дефолту
Чтобы группа other не имела никаких прав после создания файла
umask 0006
touch x.txt
RESULT: -rw-rw---- 1 nanku nanku    0 сен 26 09:55 x.txt
Вернуть права по дефолту для группы other
umask 0002  (666-002 = 664 = rw-rw-r = 42-42-4)
touch x.txt
RESULT: -rw-rw-r-- 1 nanku nanku    0 сен 26 09:55 x.txt


## Процессы
ps aux  - процессы, все, человекочитаемо, +демоны
ps ux - процессы текущего пользователя
pstree -p pid  - дерево процессов от родительского
pgrep поможет с поиском PID по имени процесса:
pgrep -a bash # выведет PID всех процессов с именем nginx

остановить процесс корректно
kill -15  pid  (SIGTERM)
убить сразу процесс
kill -9 pid   (SIGKILL)

показывает открытые файлы и процессы, которые их используют:
lsof -i :80 # найти процесс, использующий порт 80

## Приоритеты процессов
Назначение приоритета при запуске процесса
nice -n 15 tar -czf backup.tar.gz /data

Почему мы не можем установить nice=-10 без sudo? Это мера безопасности. Только root может повышать приоритет, чтобы пользователи не нарушали баланс системы.

Изменение приоритета работающего процесса
renice -n 15 -p 1234 # установить nice=15

Проверка текущего приоритета
ps -o pid,ni,cmd -p <PID> # вывод PID, nice и команды

Какое значение nice имеет наивысший приоритет?
-20  (минус 20)

## systemd
https://study.selectel.ru/members/courses/course756726784647/zadania-po-teme-upravlenie-fonovymi-processami-demonami-v-linux-274426602256

можно создавать свои сервисы, таймеры, демоны
Проверить созданный юнит
systemd-analyze verify /etc/systemd/system/mydaemon.service

убрать сервис из автозагрузки и сразу выключить
sudo systemctl disable --now nginx

запрет на включение сервиса
sudo systemctl mask nginx